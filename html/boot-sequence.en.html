<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Boot Sequence of genpack Images</title>
<link rel="stylesheet" href="css/style.css">
<link rel="icon" href="image/favicon.png">
<meta property="og:title" content="Boot Sequence of genpack Images" />
<meta property="og:description" content="Detailed boot sequence walkthrough for both disk install (system.img) and paravirtual (vm command) methods" />
<meta property="og:image" content="https://www.walbrix.co.jp/genpack/image/article.png" />
<meta property="og:url" content="https://www.walbrix.co.jp/genpack/boot-sequence.en.html" />
<meta property="og:type" content="article" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="Boot Sequence of genpack Images" />
<meta name="twitter:description" content="Detailed boot sequence walkthrough for both disk install (system.img) and paravirtual (vm command) methods" />
<meta name="twitter:image" content="https://www.walbrix.co.jp/genpack/image/article.png" />
<meta name="twitter:site" content="@wbrxcorp" />
</head>
<body class="en">

<p class="last-updated">
Last updated: <time>2026-02-28</time>
</p>

<!-- content:begin -->
<h1>Boot Sequence of genpack Images</h1>

<h2>Overview</h2>

<p>SquashFS images generated by genpack can be booted in two ways: on physical hardware installed to disk, and in a QEMU/KVM paravirtual environment via the <code>vm</code> command. In both cases, a common initramfs (dracut-genpack) constructs an overlayfs root, and genpack-init performs initial configuration based on system.ini before handing control to systemd.</p>

<p>This document describes the boot sequence for both methods in detail.</p>

<h2>system.img Method (Disk Install)</h2>

<h3>Disk Layout</h3>

<p>When installed to disk with <code>genpack-install</code>, the following partition layout is created:</p>

<table>
<thead><tr><th>Partition</th><th>Filesystem</th><th>Contents</th></tr></thead>
<tbody>
<tr><td>1: Boot partition</td><td>FAT32</td><td>EFI bootloader, kernel, initramfs, system.img (if &lt; 4GiB), system.ini</td></tr>
<tr><td>2: Data partition</td><td>Btrfs</td><td>overlayfs upper layer, system (if &gt;= 4GiB)</td></tr>
</tbody>
</table>

<p>The boot partition size is automatically calculated from the image size. The <code>--superfloppy</code> option skips partition table creation and uses the entire disk as FAT32 (no data partition).</p>

<p>MBR or GPT is automatically selected based on disk size (MBR for &lt;= 2TiB with 512-byte sectors, GPT otherwise).</p>

<h3>Boot Sequence</h3>

<div class="boot-flow">
<span class="stage">UEFI/BIOS</span>
<span class="arrow">→</span>
<span class="stage">GRUB</span>
<span class="arrow">→</span>
<span class="stage">Linux kernel</span>
<span class="arrow">→</span>
<span class="stage">initramfs (dracut-genpack)</span>
<span class="arrow">→</span>
<span class="stage">overlayfs root construction</span>
<span class="arrow">→</span>
<span class="stage">genpack-init (PID 1)</span>
<span class="arrow">→</span>
<span class="stage">Python plugins</span>
<span class="arrow">→</span>
<span class="stage">exec /sbin/init (systemd)</span>
</div>

<p>The kernel command line specifies <code>root=systemimg:&lt;UUID&gt;</code> or <code>root=systemimg:auto</code>.</p>

<h3>Bootloader</h3>

<p>genpack-install builds GRUB bootloaders for each architecture and bundles them in the SquashFS image at <code>/usr/lib/genpack-install/</code>.</p>

<p><strong>EFI bootloaders:</strong></p>

<p>Built with <code>grub-mkstandalone</code>, each is a standalone EFI binary with grub.cfg <strong>embedded</strong> inside. No external configuration file is needed on disk.</p>

<table>
<thead><tr><th>Binary</th><th>Target</th></tr></thead>
<tbody>
<tr><td><code>bootx64.efi</code></td><td>x86_64</td></tr>
<tr><td><code>bootia32.efi</code></td><td>i386</td></tr>
<tr><td><code>bootaa64.efi</code></td><td>ARM64</td></tr>
<tr><td><code>bootriscv64.efi</code></td><td>RISC-V 64</td></tr>
</tbody>
</table>

<p><strong>BIOS bootloader:</strong></p>

<p>A combination of <code>boot.img</code> (MBR stage 1) and <code>core.img</code> (generated by <code>grub-mkimage</code>). The prefix <code>(,msdos1)/boot/grub</code> is hardcoded into <code>core.img</code>, which reads <code>/boot/grub/grub.cfg</code> from the boot partition. For BIOS, grub.cfg is not embedded in the binary — <code>genpack-install</code> places it on the boot partition during disk installation.</p>

<h3>grub.cfg Processing Flow</h3>

<p>The grub.cfg — embedded in EFI binaries or placed on the boot partition for BIOS — performs the following:</p>

<div class="flow-diagram">
<ol>
<li>
<span class="step-title">Serial console initialization</span>
<ul>
<li>Attempts COM0 at 115200 baud</li>
<li>On success, both serial and console are configured as input/output terminals</li>
</ul>
</li>
<li>
<span class="step-title">Boot partition identification</span>
<ul>
<li>Determines the boot partition from the GRUB variable <code>$cmdpath</code> (the path from which the bootloader was loaded)</li>
<li>Obtains its UUID via <code>probe -u</code></li>
</ul>
</li>
<li>
<span class="step-title">System image detection</span>
<ul>
<li>Search for <code>system.img</code> on the boot partition</li>
<li>If not found, search for <code>system</code> on the data partition (by label <code>data-&lt;UUID&gt;</code> → <code>d-&lt;UUID&gt;</code> → fallback to partition number)</li>
</ul>
</li>
<li>
<span class="step-title">SquashFS mount and kernel detection</span>
<ul>
<li>Loop-mount SquashFS via the <code>loopback</code> command and switch root with <code>set root=loop</code></li>
<li>If the image contains <code>/boot/grub/grub.cfg</code>, delegate to it via <code>configfile</code> (allows the image to override boot configuration)</li>
<li>If no such file exists, continue with the following steps</li>
</ul>
</li>
<li>
<span class="step-title">Timeout determination</span>
<ul>
<li><code>boottime.txt</code> persists (evidence of previous unclean shutdown <sup><a href="#fn1">[1]</a></sup>) → 10 seconds</li>
<li>Normal → 1 second</li>
</ul>
</li>
<li>
<span class="step-title">Custom configuration loading</span>
<ul>
<li>If <code>system.cfg</code> exists on the boot partition, load it via <code>source</code></li>
<li>The <code>LINUX_ARGS</code> variable can be set to customize the kernel command line</li>
</ul>
</li>
<li>
<span class="step-title">Kernel command line construction</span>
<ul>
<li><code>panic=30</code> added by default (unless explicitly specified)</li>
<li>On x86, <code>console=ttyS0,115200n8r console=tty0</code> added (unless explicitly specified)</li>
</ul>
</li>
<li>
<span class="step-title">Menu entries</span>
<ul>
<li>Normal mode: <code>linux /boot/kernel root=systemimg:&lt;UUID&gt; $LINUX_ARGS systemd.firstboot=0</code></li>
<li>Transient mode: adds <code>genpack.transient=1</code> to the above</li>
<li>Kernel and initramfs loaded from <code>/boot/kernel</code> and <code>/boot/initramfs</code> inside the SquashFS (already loop-mounted)</li>
<li>Additional menu entries shown if MemTest86 is available</li>
</ul>
</li>
</ol>
</div>

<h3>initramfs Processing (dracut-genpack)</h3>

<p>dracut-genpack consists of two hooks.</p>

<p><strong>cmdline hook (check-systemimg-root.sh):</strong></p>

<p>Checks the <code>root=</code> parameter in the kernel command line. If it matches the <code>root=systemimg:...</code> format, the genpack boot sequence begins.</p>

<p><strong>mount hook (mount-genpack.sh):</strong></p>

<div class="flow-diagram">
<ol>
<li>
<span class="step-title">Boot partition detection and mount</span>
<ul>
<li><code>root=systemimg:&lt;UUID&gt;</code>: Mount the partition with the specified UUID</li>
<li><code>root=systemimg:auto</code>: Scan all FAT partitions to find one containing <code>system.img</code></li>
<li>For FAT, run <code>fsck.fat -aw</code> for automatic repair before mounting</li>
<li>Mount point: <code>/run/initramfs/boot</code></li>
</ul>
</li>
<li>
<span class="step-title">Data partition detection and mount</span>
<ul>
<li>Search by label <code>data-&lt;UUID&gt;</code> based on the boot partition's UUID</li>
<li>Fallback: <code>d-&lt;UUID&gt;</code>, <code>wbdata-&lt;UUID&gt;</code>, or next partition number <sup><a href="#fn2" id="fnref2">[2]</a></sup></li>
<li>If not found, attempt virtiofs (<code>fs</code> tag) <sup><a href="#fn3" id="fnref3">[3]</a></sup></li>
<li>If still unmountable, fall back to tmpfs (transient mode)</li>
<li><code>genpack.transient</code> kernel parameter can explicitly specify transient mode</li>
<li>Mount point: <code>/run/initramfs/rw</code></li>
</ul>
</li>
<li>
<span class="step-title">SquashFS image mount</span>
<ul>
<li>Search for <code>/run/initramfs/boot/system.img</code> on the boot partition</li>
<li>If not found, use <code>/run/initramfs/rw/system</code> on the data partition</li>
<li>Mount read-only at <code>/run/initramfs/ro</code></li>
</ul>
</li>
<li>
<span class="step-title">overlayfs construction</span>
<ul>
<li>lowerdir: <code>/run/initramfs/ro</code> (SquashFS, read-only)</li>
<li>upperdir: <code>/run/initramfs/rw/root</code> (Btrfs or tmpfs) <sup><a href="#fn5" id="fnref5">[5]</a></sup></li>
<li>workdir: <code>/run/initramfs/rw/work</code></li>
<li>Mount overlay at <code>$NEWROOT</code></li>
<li>Synchronize lower layer's <code>/usr</code> timestamp to the upper layer <sup><a href="#fn4" id="fnref4">[4]</a></sup></li>
</ul>
</li>
<li>
<span class="step-title">Shutdown program placement</span>
<ul>
<li>Copy <code>/run/initramfs/ro/usr/libexec/genpack-shutdown</code> to <code>/run/initramfs/shutdown</code></li>
<li>Used for safely unmounting overlayfs and SquashFS during shutdown</li>
</ul>
</li>
</ol>
</div>

<h3>genpack-init</h3>

<p>Once dracut's initramfs processing completes, the root switches to <code>$NEWROOT</code> and <code>/usr/bin/genpack-init</code> starts as PID 1 (<code>init=/usr/bin/genpack-init</code> is added to the cmdline by the dracut module).</p>

<p>genpack-init is implemented in C++ + pybind11 and performs the following:</p>

<ol>
<li>Load <code>/run/initramfs/boot/system.ini</code> (via boot partition) or <code>/run/initramfs/rw/system.ini</code> (via data partition)</li>
<li>Load all Python modules in <code>/usr/lib/genpack-init/*.py</code> in filename order</li>
<li>Execute each module's <code>configure(ini)</code> function (timezone, locale, banner display, machine ID generation, etc.)</li>
<li>Hand control to systemd via <code>exec /sbin/init</code></li>
</ol>

<h2>Paravirtual Method (vm command)</h2>

<h3>vm Command Overview</h3>

<p>The <code>vm</code> command is a tool for directly booting genpack images with QEMU/KVM. No disk installation is required — you can specify and boot a SquashFS file directly.</p>

<h3>Boot Sequence</h3>

<div class="boot-flow">
<span class="stage">vm run system.squashfs</span>
<span class="arrow">→</span>
<span class="stage">Extract kernel from SquashFS (memfd)</span>
<span class="arrow">→</span>
<span class="stage">qemu-system-&lt;arch&gt;</span>
<span class="arrow">→</span>
<span class="stage">initramfs (dracut-genpack)</span>
<span class="arrow">→</span>
<span class="stage">overlayfs root construction</span>
<span class="arrow">→</span>
<span class="stage">genpack-init (PID 1)</span>
<span class="arrow">→</span>
<span class="stage">exec /sbin/init (systemd)</span>
</div>

<h3>Kernel and initramfs Extraction</h3>

<p>The vm command uses the squashfuse library to read the kernel and initramfs directly from the <code>/boot/</code> directory within the SquashFS image. There is no need to extract to disk — the files are written to file descriptors created with <code>memfd_create</code> and passed to QEMU.</p>

<p>Search order:</p>
<ol>
<li><code>boot/kernel</code> or <code>boot/vmlinuz</code> (fixed names)</li>
<li><code>boot/kernel-*</code> or <code>boot/vmlinuz-*</code> (most recent by timestamp)</li>
</ol>

<p>initramfs is similarly searched in the order: <code>boot/initramfs</code>, <code>boot/initramfs.img</code>, <code>boot/initrd.img</code>.</p>

<p>The architecture (x86_64, aarch64, riscv64, etc.) is automatically detected from the ELF header or PE header of the kernel binary, and the corresponding <code>qemu-system-&lt;arch&gt;</code> is launched.</p>

<h3>QEMU Launch Configuration</h3>

<p>The vm command uses QEMU's direct kernel boot (<code>-kernel</code>, <code>-initrd</code>, <code>-append</code>). No bootloader is involved.</p>

<p><strong>Kernel command line:</strong></p>

<pre><code>root=/dev/vda ro net.ifnames=0 systemd.firstboot=0 systemd.hostname=&lt;vmname&gt; console=...</code></pre>

<ul>
<li><code>root=/dev/vda</code>: The SquashFS image is provided as a virtio-blk device</li>
<li>For virtiofs mode: <code>root=fs rootfstype=virtiofs rw</code></li>
</ul>

<p><strong>Disk provisioning:</strong></p>

<table>
<thead><tr><th>virtio device</th><th>Serial</th><th>Contents</th></tr></thead>
<tbody>
<tr><td>vda</td><td>system</td><td>SquashFS image (read-only)</td></tr>
<tr><td>vdb</td><td>data</td><td>Data disk (if present)</td></tr>
<tr><td>vdc</td><td>swap</td><td>Swap file (if present)</td></tr>
</tbody>
</table>

<p>The SquashFS image is attached as a <code>virtio-blk-pci</code> device in read-only mode. The initramfs <code>mount-genpack.sh</code> references the kernel command line's <code>root=/dev/vda</code> (not <code>root=block:*</code>) and mounts <code>/dev/vda</code> directly as SquashFS at <code>/run/initramfs/ro</code>.</p>

<p><strong>virtiofs mode:</strong></p>

<p>The vm command also supports virtiofs. It launches virtiofsd to share a host directory with the guest, which can be used as the overlayfs upper layer. When using virtiofs, the initramfs mounts virtiofs as root based on <code>root=fs rootfstype=virtiofs rw</code>.</p>

<h3>vm Service Mode</h3>

<p>The <code>vm</code> command has a service mode that reads <code>vm.ini</code> files. The directory structure for each VM is as follows:</p>

<div class="tree-diagram">
<ul>
<li><span class="label">/var/vm/&lt;vmname&gt;/</span>
<ul>
<li><span class="label">vm.ini</span> <span class="desc">— VM configuration (memory, CPU, network, etc.)</span></li>
<li><span class="label">system</span> <span class="desc">— SquashFS image (can be a symlink)</span></li>
<li><span class="label">data</span> <span class="desc">— Data disk (optional)</span></li>
<li><span class="label">swapfile</span> <span class="desc">— Swap (optional)</span></li>
<li><span class="label">fs/</span> <span class="desc">— virtiofs shared directory</span></li>
<li><span class="label">docker</span> <span class="desc">— Docker disk (optional, serial=docker)</span></li>
<li><span class="label">mysql</span> <span class="desc">— MySQL disk (optional, serial=mysql)</span></li>
</ul>
</li>
</ul>
</div>

<p><code>type=genpack</code> (the default) in <code>vm.ini</code> enables direct kernel boot.</p>

<h3>Comparison with the system.img Method</h3>

<table>
<thead><tr><th>Aspect</th><th>system.img method</th><th>Paravirtual method</th></tr></thead>
<tbody>
<tr><td>Bootloader</td><td>GRUB (EFI/BIOS)</td><td>None (direct kernel boot)</td></tr>
<tr><td>Kernel location</td><td>File on boot partition</td><td>Extracted from SquashFS to memfd</td></tr>
<tr><td>root= parameter</td><td><code>systemimg:&lt;UUID&gt;</code> or <code>systemimg:auto</code></td><td><code>/dev/vda</code></td></tr>
<tr><td>SquashFS delivery</td><td>File on boot/data partition</td><td>virtio-blk device</td></tr>
<tr><td>Data persistence</td><td>Btrfs partition</td><td>Data disk file or virtiofs</td></tr>
<tr><td>Transient mode</td><td><code>genpack.transient</code> kernel parameter</td><td>Automatic when no data disk specified</td></tr>
<tr><td>system.ini</td><td>On FAT32 partition</td><td>Via virtiofs or fw_cfg</td></tr>
<tr><td>initramfs behavior</td><td>Common (dracut-genpack)</td><td>Common (dracut-genpack)</td></tr>
<tr><td>genpack-init behavior</td><td>Common</td><td>Common</td></tr>
</tbody>
</table>

<h2>Shutdown</h2>

<p>Shutdown of a genpack image follows the normal systemd shutdown process, after which control returns to dracut's initramfs and <code>/run/initramfs/shutdown</code> (genpack-shutdown) executes. genpack-shutdown performs the following:</p>

<ol>
<li>Unmount all mount points under <code>/oldroot</code> in reverse order</li>
<li>Safely move and unmount <code>/run/initramfs/rw</code> (data partition) and <code>/run/initramfs/boot</code> (boot partition)</li>
<li>Delete <code>boottime.txt</code> on the boot partition <sup><a href="#fn1" id="fnref1">[1]</a></sup></li>
<li>Execute <code>reboot(2)</code> or <code>poweroff</code></li>
</ol>

<section class="footnotes">
<ol>
<li id="fn1">boottime.txt is created at boot time. Since it is deleted during a clean shutdown, its presence at the next boot serves as evidence of an unclean shutdown (crash or power loss). <a href="#fnref1">↩</a></li>
<li id="fn2"><code>d-&lt;UUID&gt;</code> is the current canonical label format (shortened due to Btrfs label length limitations). <code>data-&lt;UUID&gt;</code> and <code>wbdata-&lt;UUID&gt;</code> are retained for backward compatibility with the Walbrix era (genpack's predecessor). <a href="#fnref2">↩</a></li>
<li id="fn3">The systemimg method is not exclusive to physical hardware — it can also be used when running directly on QEMU without the vm frontend. This fallback allows baremetal profile images to boot in paravirtual environments as well. This is also why the baremetal profile exists as a specialization of systemimg. <a href="#fnref3">↩</a></li>
<li id="fn4">systemd uses the <code>/usr</code> timestamp to determine whether <code>ld.so.cache</code> needs to be regenerated. In overlayfs, the upper layer's presence masks the lower layer's timestamps, so the lower layer's <code>/usr</code> timestamp must be explicitly propagated to the upper layer. <a href="#fnref4">↩</a></li>
<li id="fn5">In older versions, the upperdir used the redundant path <code>rw/rw/root</code>. This was simplified to <code>rw/root</code>, but the initramfs continues to recognize the old path <code>rw/rw/root</code> for backward compatibility with existing deployments. <a href="#fnref5">↩</a></li>
</ol>
</section>

<section class="source-references">
<h2>Source References</h2>

<p>This document was created based on snapshots of the following repositories:</p>

<ul>
<li><a href="https://github.com/wbrxcorp/genpack-install">wbrxcorp/genpack-install @ HEAD</a></li>
<li><a href="https://github.com/wbrxcorp/genpack-overlay">wbrxcorp/genpack-overlay @ HEAD</a> (sys-kernel/dracut-genpack, genpack/base)</li>
<li><a href="https://github.com/wbrxcorp/genpack-init">wbrxcorp/genpack-init @ HEAD</a></li>
<li><a href="https://github.com/shimarin/vm">shimarin/vm @ HEAD</a></li>
</ul>
</section>
<!-- content:end -->

<section class="update-history">
<h2>Update History</h2>
<ul>
<li><time>2026-02-28</time> — Add bootloader and grub.cfg processing flow sections</li>
<li><time>2026-02-28</time> — Add design rationale footnotes to boot sequence documentation</li>
<li><time>2026-02-28</time> — Add boot sequence documentation for genpack images</li>
</ul>
<p class="history-link"><a href="history.en.html">See all update history</a></p>
</section>

<nav class="doc-nav">
<h2>Other Documents</h2>
<ul>
<li><a href="index.en.html">genpack — A Gentoo-Based Immutable System Image Build Toolchain</a></li>
<li><a href="json5.en.html">genpack.json5 Specification Reference</a></li>
<li><a href="subdirectories.en.html">Artifact Directory Structure</a></li>
<li><a href="profiles.en.html">genpack-overlay Profile Reference</a></li>
<li><a href="cli.en.html">genpack CLI Reference</a></li>
<li><a href="cli-install.en.html">genpack-install CLI Reference</a></li>
<li><a href="overlay-devlauncher.en.html">genpack/devlauncher Metapackage</a></li>
<li><a href="overlay-genpack-progs.en.html">genpack/genpack-progs Package</a></li>
<li><a href="artifact-stub.en.html">stub — Multi-Distribution Installer and kexec Boot Loader for VMs</a></li>
<li><a href="uvp.en.html">A Conversation with Gemini about genpack's Unique Value Proposition</a></li>
</ul>
</nav>

</body>
</html>
